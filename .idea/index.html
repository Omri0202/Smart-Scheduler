<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    <title>Smart Scheduler</title>
    
    <!-- PWA Meta Tags -->
    <link rel="manifest" href="../manifest.json" />
    <meta name="theme-color" content="#667eea" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="default" />
    <meta name="apple-mobile-web-app-title" content="Smart Scheduler" />
    <link rel="apple-touch-icon" href="../icon-192.png" />
    
    <!-- Mobile Optimizations -->
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="format-detection" content="telephone=no" />
    
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <script src="https://apis.google.com/js/api.js"></script>
    <style>
        body, html {
  margin: 0;
  padding: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  height: 100vh;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: black;
  transition: background-color 0.3s, color 0.3s;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  touch-action: manipulation;
  user-select: none;
  -webkit-user-select: none;
  -webkit-touch-callout: none;
  -webkit-tap-highlight-color: transparent;
}
#cornerText {
 position: fixed;
 top: 20px;
 left: 20px;
 background: rgba(255,255,255,0.7);
 padding: 10px 15px;
 font-weight: bold;
 border-radius: 6px;
}
        #container {
  background: rgba(255,255,255,0.95);
  max-width: 500px;
  width: 90%;
  margin: 5% auto 0;
  padding: 20px;
  border-radius: 20px;
  box-shadow: 0 8px 32px rgba(0,0,0,0.2);
  text-align: center;
  height: 60vh;
  overflow-y: auto;
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
}
        #inputContainer {
  position: fixed;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  width: 90%;
  max-width: 500px;
  display: flex;
  gap: 10px;
  align-items: center;
}

input[type="text"] {
  flex: 1;
  padding: 16px 20px;
  border: none;
  border-radius: 25px;
  font-size: 16px;
  outline: none;
  background: rgba(255,255,255,0.95);
  box-shadow: 0 4px 20px rgba(0,0,0,0.1);
  -webkit-appearance: none;
  appearance: none;
  touch-action: manipulation;
  min-height: 44px;
  box-sizing: border-box;
}

button {
  padding: 12px 20px;
  font-size: 16px;
  border-radius: 8px;
  border: none;
  background: #007BFF;
  color: white;
  cursor: pointer;
}

#voiceButton {
  padding: 12px;
  border-radius: 50%;
  width: 50px;
  height: 50px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: #28a745;
  color: white;
  border: none;
  cursor: pointer;
  font-size: 18px;
}

#voiceButton.recording {
  background: #dc3545;
  animation: pulse 1s infinite;
}

@keyframes pulse {
  0% { transform: scale(1); }
  50% { transform: scale(1.1); }
  100% { transform: scale(1); }
}
button:hover { background: #0056b3; }
#message {
 margin-top: 15px;
 min-height: 30px;
}
#darkToggle {
 position: fixed;
 top: 20px;
 right: 20px;
 background: rgba(255,255,255,0.7);
 padding: 8px 12px;
 border-radius: 8px;
 cursor: pointer;
 font-weight: bold;
}
        body.dark {
  background: linear-gradient(135deg, #1a1a1a 0%, #2d1b69 100%);
  color: white;
}
body.dark #container { background: #1e1e1e; color: white; }
body.dark input, body.dark button { background: #333; color: white; }
body.dark #cornerText, body.dark #darkToggle {
 background: rgba(0,0,0,0.7);
 color: #00aaff;
}
    </style>
</head>
<body>
<div id="cornerText">let me plan your schedule</div>
<div id="darkToggle">Toggle Dark Mode</div>

<div id="container">
    <h2>Smart Scheduler</h2>
    <div id="message">Please sign in to get started.</div>
    <button id="authorize_button" style="display:none;">Authorize Google Calendar</button>
    <button id="signout_button" style="display:none;">Sign Out</button>
</div>

<div id="inputContainer">
    <input type="text" id="inputBox" placeholder="What are your plans?" disabled />
    <button id="voiceButton" disabled>ðŸŽ¤</button>
</div>

<script>
    const CLIENT_ID = '251900786787-rs2a373jkaetk9lmh49nch3tq5p3lnhp.apps.googleusercontent.com';
    // SECURITY WARNING: API keys should not be exposed in client-side code
    // In production, this should be handled by a backend server
    const TOGETHER_API_KEY = '1e60c638e6c99899e27a3bec16b056dfd8fc1e5cace56a9c09e3a324f0de8f39';
    const SCOPES = 'https://www.googleapis.com/auth/calendar.events';
    const DISCOVERY_DOCS = ["https://www.googleapis.com/discovery/v1/apis/calendar/v3/rest"];

    let tokenClient, accessToken = null;
    let gapiInited = false, gisInited = false;
    let chatHistory = [];
    let questionCount = 0;
    let baseDate = new Date(); // Base date for the session
    let eventDetails = {
      date: null,
      time: null,
      attendees: null,
      location: null,
      attendeeEmails: []
    };

    // Validate API key format
    function validateApiKey(apiKey) {
      if (!apiKey || typeof apiKey !== 'string' || apiKey.length < 10) {
        console.error('Invalid API key format');
        return false;
      }
      return true;
    }

    // Function to track what information we still need
    function getMissingInfo() {
      const missing = [];
      if (!eventDetails.date) missing.push('date/day');
      if (!eventDetails.time) missing.push('time');
      if (!eventDetails.attendees) missing.push('who is attending');
      if (!eventDetails.location) missing.push('location');
      return missing;
    }

    // Function to get context-aware missing info
    function getContextualMissingInfo() {
      const missing = getMissingInfo();
      const contextualMissing = [];

      for (const item of missing) {
        if (item === 'time' && eventDetails.date) {
          contextualMissing.push(`time for ${eventDetails.date}`);
        } else {
          contextualMissing.push(item);
        }
      }

      return contextualMissing;
    }

    // Function to parse date and time into a DateTime object
    function parseDateTime(dateStr, timeStr) {
      if (!dateStr || !timeStr) return null;

      // Use baseDate instead of current time for consistent calculations
      let targetDate = new Date(baseDate);

      // Parse date
      const dateLower = dateStr.toLowerCase();
      if (dateLower === 'today') {
        targetDate = new Date(baseDate);
      } else if (dateLower === 'tomorrow') {
        targetDate = new Date(baseDate.getTime() + 24 * 60 * 60 * 1000);
      } else if (dateLower.startsWith('next ')) {
        const day = dateLower.replace('next ', '');
        const days = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
        const targetDay = days.indexOf(day);
        if (targetDay !== -1) {
          const currentDay = baseDate.getDay();
          let daysToAdd = targetDay - currentDay;
          if (daysToAdd <= 0) daysToAdd += 7;
          targetDate = new Date(baseDate.getTime() + daysToAdd * 24 * 60 * 60 * 1000);
          console.log(`Next ${day}: base day ${currentDay}, target day ${targetDay}, days to add ${daysToAdd}`);
        }
      } else if (dateLower.startsWith('this ')) {
        const day = dateLower.replace('this ', '');
        const days = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
        const targetDay = days.indexOf(day);
        if (targetDay !== -1) {
          const currentDay = baseDate.getDay();
          let daysToAdd = targetDay - currentDay;
          if (daysToAdd < 0) daysToAdd += 7;
          targetDate = new Date(baseDate.getTime() + daysToAdd * 24 * 60 * 60 * 1000);
        }
      } else {
        // Handle just day names like "monday", "tuesday", etc.
        const days = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
        if (days.includes(dateLower)) {
          const targetDay = days.indexOf(dateLower);
          if (targetDay !== -1) {
            const currentDay = baseDate.getDay();
            let daysToAdd = targetDay - currentDay;
            // If it's the same day or past, schedule for next week
            if (daysToAdd <= 0) daysToAdd += 7;
            targetDate = new Date(baseDate.getTime() + daysToAdd * 24 * 60 * 60 * 1000);
            console.log(`Scheduling for ${dateLower}: base day ${currentDay}, target day ${targetDay}, days to add ${daysToAdd}`);
          }
        }
      }

      // Parse time
      const timeLower = timeStr.toLowerCase();
      let hours = 0, minutes = 0;

      // Handle formats like "9 AM", "2:30 PM", "14:30"
      const timeMatch = timeLower.match(/(\d{1,2}):?(\d{2})?\s*(am|pm)?/);
      if (timeMatch) {
        hours = parseInt(timeMatch[1]);
        minutes = timeMatch[2] ? parseInt(timeMatch[2]) : 0;

        if (timeMatch[3]) {
          const isPM = timeMatch[3] === 'pm';
          if (isPM && hours !== 12) hours += 12;
          if (!isPM && hours === 12) hours = 0;
        }
      }

      // Set the time on the target date
      targetDate.setHours(hours, minutes, 0, 0);

      console.log(`Time parsing: "${timeStr}" -> hours: ${hours}, minutes: ${minutes}, final time: ${targetDate.toLocaleString()}`);

      return targetDate;
    }

    // Function to extract and update event details from user input
    function updateEventDetails(userInput) {
      const input = userInput.toLowerCase();

      // Extract date patterns (only if we don't already have a date)
      if (!eventDetails.date) {
        const datePatterns = [
          /(today|tomorrow|next \w+|this \w+)/i,
          /(\d{1,2}\/\d{1,2}|\d{1,2}-\d{1,2})/,
          /(monday|tuesday|wednesday|thursday|friday|saturday|sunday)/i,
          /(january|february|march|april|may|june|july|august|september|october|november|december)/i
        ];

        let dateFound = false;
        for (const pattern of datePatterns) {
          const match = input.match(pattern);
          if (match) {
            eventDetails.date = match[0];
            dateFound = true;
            break;
          }
        }

        // If no date is mentioned, assume today
        if (!dateFound) {
          eventDetails.date = 'today';
        }
      }

      // Extract time patterns
      if (!eventDetails.time) {
        const timePatterns = [
          /(\d{1,2}:\d{2}\s*(am|pm))/i,
          /(\d{1,2}\s*(am|pm))/i,
          /(\d{1,2}:\d{2})/,
          /(\d{1,2}\s*o'clock)/i,
          /^(\d{1,2})$/  // Handle single digits like "9"
        ];

        for (const pattern of timePatterns) {
          const match = input.match(pattern);
          if (match) {
            eventDetails.time = match[0];
            console.log(`Time extracted: "${match[0]}" from input "${userInput}"`);
            break;
          }
        }
      }

      // If we have a date but no time, and the input looks like just a time, extract it
      if (eventDetails.date && !eventDetails.time) {
        const timeOnlyPatterns = [
          /^(\d{1,2}:\d{2}\s*(am|pm))$/i,
          /^(\d{1,2}\s*(am|pm))$/i,
          /^(\d{1,2}:\d{2})$/,
          /^(\d{1,2}\s*o'clock)$/i,
          /^(\d{1,2})$/  // Handle single digits like "9"
        ];

        for (const pattern of timeOnlyPatterns) {
          const match = input.match(pattern);
          if (match) {
            eventDetails.time = match[0];
            console.log(`Time-only extracted: "${match[0]}" from input "${userInput}"`);
            break;
          }
        }
      }

      // Extract attendees - prioritize patterns that include other people
      if (!eventDetails.attendees) {
        // First check for patterns that include other people
        const otherPeoplePatterns = [
          /(with\s+my\s+\w+)/i,  // "with my mom", "with my dad"
          /(and\s+my\s+\w+)/i,   // "and my mom"
          /(me\s+and\s+\w+)/i,   // "me and mom"
          /(\w+\s+and\s+me)/i,   // "mom and me"
          /(mom|mother|dad|father|brother|sister|family)/i,
          /(friend|friends|colleague|colleagues|team)/i,
          /(spouse|wife|husband|girlfriend|boyfriend|partner)/i,
          /(boss|manager|client|doctor|teacher)/i
        ];
        
        // Then check for solo patterns
        const soloPatterns = [
          /(myself|me|i|alone)/i,
          /(just\s+\w+)/i
        ];

        // Try other people patterns first
        for (const pattern of otherPeoplePatterns) {
          const match = input.match(pattern);
          if (match) {
            eventDetails.attendees = match[0];
            console.log(`Attendees extracted (with others): "${match[0]}"`);
            break;
          }
        }
        
        // If no other people found, try solo patterns
        if (!eventDetails.attendees) {
          for (const pattern of soloPatterns) {
            const match = input.match(pattern);
            if (match) {
              eventDetails.attendees = match[0];
              console.log(`Attendees extracted (solo): "${match[0]}"`);
              break;
            }
          }
        }
      }

      // Extract location
      if (!eventDetails.location) {
        const locationPatterns = [
          /(at|in|to)\s+(\w+)/i,
          /(bank|home|office|school|hospital|restaurant|cafe|store|mall|park|gym|library|church|airport)/i,
          /(the\s+\w+)/i
        ];

        for (const pattern of locationPatterns) {
          const match = input.match(pattern);
          if (match) {
            eventDetails.location = match[0];
            break;
          }
        }
      }

      // Extract email addresses for invitations
      const emailPattern = /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/g;
      const emailMatches = userInput.match(emailPattern);
      if (emailMatches) {
        emailMatches.forEach(email => {
          if (!eventDetails.attendeeEmails.includes(email)) {
            eventDetails.attendeeEmails.push(email);
            console.log(`Email added for invitation: ${email}`);
          }
        });
      }

      // Handle "no" responses to email requests
      if (input.includes('no') && input.length < 10) {
        console.log('User declined to provide email addresses');
      }
    }

    // Function to check if other people are mentioned in attendees
    function requiresEmailInvitation() {
      if (!eventDetails.attendees) {
        console.log('requiresEmailInvitation: No attendees found');
        return false;
      }
      
      const attendeesLower = eventDetails.attendees.toLowerCase();
      console.log(`requiresEmailInvitation: Checking attendees: "${eventDetails.attendees}"`);
      
      const otherPeopleKeywords = [
        'mom', 'mother', 'dad', 'father', 'brother', 'sister', 
        'friend', 'colleague', 'team', 'family', 'spouse', 
        'wife', 'husband', 'girlfriend', 'boyfriend', 'partner',
        'boss', 'manager', 'client', 'doctor', 'teacher'
      ];
      
      // Check if any keywords for other people are mentioned
      const mentionsOthers = otherPeopleKeywords.some(keyword => 
        attendeesLower.includes(keyword)
      );
      
      // Don't require email if it's just the user
      const justUser = attendeesLower.includes('myself') || 
                      attendeesLower.includes('me') || 
                      attendeesLower.includes('alone') ||
                      attendeesLower === 'i';
      
      const result = mentionsOthers && !justUser;
      console.log(`requiresEmailInvitation: mentionsOthers=${mentionsOthers}, justUser=${justUser}, result=${result}`);
      
      return result;
    }

    // Function to generate a smart event name using LLM
    async function generateSmartEventName() {
      const prompt = `Create a concise, descriptive event title based on these details:
- Date: ${eventDetails.date}
- Time: ${eventDetails.time}
- Attendees: ${eventDetails.attendees}
- Location: ${eventDetails.location}

Generate a natural, professional event title (2-6 words). Examples:
- "Bank Visit with Mom"
- "Team Meeting at Office"
- "Lunch with Friends"
- "Doctor Appointment"
- "Family Dinner"

Respond with ONLY the event title, no quotes or extra text.`;

      try {
        const body = {
          model: "mistralai/Mixtral-8x7B-Instruct-v0.1",
          messages: [
            {
              role: "system",
              content: "You are an expert at creating concise, professional event titles. Respond with only the event title, nothing else."
            },
            {
              role: "user",
              content: prompt
            }
          ],
          max_tokens: 50,
          temperature: 0.3
        };

        const response = await fetch("https://api.together.xyz/v1/chat/completions", {
          method: "POST",
          headers: {
            "Authorization": `Bearer ${TOGETHER_API_KEY}`,
            "Content-Type": "application/json"
          },
          body: JSON.stringify(body)
        });

        if (!response.ok) {
          throw new Error(`API request failed: ${response.status}`);
        }

        const data = await response.json();
        const eventName = data.choices?.[0]?.message?.content?.trim() || "Event";
        
        console.log(`Generated smart event name: "${eventName}"`);
        return eventName;
      } catch (error) {
        console.error('Error generating smart event name:', error);
        // Fallback to a simple name
        return `${eventDetails.location ? eventDetails.location.charAt(0).toUpperCase() + eventDetails.location.slice(1) : 'Event'} ${eventDetails.attendees ? 'with ' + eventDetails.attendees : ''}`;
      }
    }

         const authBtn = document.getElementById('authorize_button');
     const signOutBtn = document.getElementById('signout_button');
     const inputBox = document.getElementById('inputBox');
     const msg = document.getElementById('message');
     const darkToggle = document.getElementById('darkToggle');
     const voiceButton = document.getElementById('voiceButton');

     // Voice recognition setup
     let recognition = null;
     if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
       recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
       recognition.continuous = false;
       recognition.interimResults = false;
       recognition.lang = 'en-US';

       recognition.onstart = () => {
         voiceButton.classList.add('recording');
         voiceButton.textContent = 'ðŸ”´';
       };

       recognition.onresult = (event) => {
         const transcript = event.results[0][0].transcript;
         inputBox.value = transcript;
         // Trigger the input event to process the voice input
         inputBox.dispatchEvent(new Event('input'));
       };

       recognition.onend = () => {
         voiceButton.classList.remove('recording');
         voiceButton.textContent = 'ðŸŽ¤';
       };

       recognition.onerror = (event) => {
         console.error('Speech recognition error:', event.error);
         voiceButton.classList.remove('recording');
         voiceButton.textContent = 'ðŸŽ¤';
       };
     }

    darkToggle.onclick = () => document.body.classList.toggle('dark');

    function gapiLoaded() {
      gapi.load('client', async () => {
        await gapi.client.init({ discoveryDocs: DISCOVERY_DOCS });
        gapiInited = true;
        enableAuth();
      });
    }

    function gisLoaded() {
      tokenClient = google.accounts.oauth2.initTokenClient({
        client_id: CLIENT_ID,
        scope: SCOPES,
        callback: ''
      });
      gisInited = true;
      enableAuth();
    }

    function enableAuth() {
      if (gapiInited && gisInited) authBtn.style.display = 'inline-block';
    }

         // Voice button click handler
     voiceButton.onclick = () => {
       if (recognition && !inputBox.disabled) {
         recognition.start();
       }
     };

     authBtn.onclick = () => {
       tokenClient.callback = (resp) => {
         if (resp.error) return msg.textContent = 'Auth error: ' + resp.error;
         accessToken = resp.access_token;
         msg.textContent = 'âœ… Authorized! Type your plan.';
         inputBox.disabled = false;
         voiceButton.disabled = false;
         authBtn.style.display = 'none';
         signOutBtn.style.display = 'inline-block';
       };
       tokenClient.requestAccessToken();
     };

         signOutBtn.onclick = () => {
       google.accounts.oauth2.revoke(accessToken);
       accessToken = null;
       inputBox.value = '';
       inputBox.disabled = true;
       voiceButton.disabled = true;
       msg.textContent = 'Signed out.';
       authBtn.style.display = 'inline-block';
       signOutBtn.style.display = 'none';
     };

        async function sendToLLM(text, isFinal = false) {
      chatHistory.push({ role: "user", content: text });

      // Get current date and time for the prompt
      const currentDateTime = new Date().toLocaleString();

      let systemPrompt = isFinal
        ? "Based on this conversation, create a calendar event. Return a JSON object with this format: {\"summary\": \"Event title\", \"dateTime\": \"2025-08-01T14:00:00Z\"}. Use ISO 8601 format and UTC time. Combine the date and time information to create the dateTime field."
        : `You are a helpful assistant that helps users schedule events. You need to gather 4 specific pieces of information: 1) Date/Day of the event, 2) Time of the event (e.g., 9 AM, 2:30 PM), 3) Who is attending (e.g., myself, mom, brother, me), and 4) Location/Where the event will be (e.g., bank, home, office). Once all details are gathered, the system will automatically generate a smart, descriptive event name.

Current date and time: {{CURRENT_DATETIME}}

Note: If no specific date is mentioned, assume the event is for today. When a user provides just a time (like "9 AM" or "11 PM"), apply it to the previously established date.

IMPORTANT: If the user mentions other people (like dad, mom, friend, brother, sister, etc.) in the attendees, ask for their Gmail address so you can invite them to the event. Say something like "Would you like me to invite [person] to this event? If so, please provide their Gmail address, or say 'no' to schedule the event just for you."

Current information gathered:
- Date: ${eventDetails.date || 'Not provided yet'}
- Time: ${eventDetails.time || 'Not provided yet'}
- Attendees: ${eventDetails.attendees || 'Not provided yet'}
- Location: ${eventDetails.location || 'Not provided yet'}
- Attendee Emails: ${eventDetails.attendeeEmails.length > 0 ? eventDetails.attendeeEmails.join(', ') : 'None collected yet'}

Still need: ${getContextualMissingInfo().join(', ')}

Ask one question at a time to gather the missing details. Be friendly and conversational. If the user provides multiple pieces of information in one response, acknowledge what you got and ask for the remaining details. When asking for time, remind the user of the date context if it's already established.`;

      // Replace the placeholder with actual current date and time
      systemPrompt = systemPrompt.replace('{{CURRENT_DATETIME}}', currentDateTime);

      const body = {
        model: "mistralai/Mixtral-8x7B-Instruct-v0.1",
        messages: [
          {
            role: "system",
            content: systemPrompt
          },
          ...chatHistory
        ],
        max_tokens: 300,
        temperature: 0.7
      };

      try {
        if (!validateApiKey(TOGETHER_API_KEY)) {
          throw new Error('Invalid API key configuration');
        }

        const response = await fetch("https://api.together.xyz/v1/chat/completions", {
          method: "POST",
          headers: {
            "Authorization": `Bearer ${TOGETHER_API_KEY}`,
            "Content-Type": "application/json"
          },
          body: JSON.stringify(body)
        });

        if (!response.ok) {
          throw new Error(`API request failed: ${response.status} ${response.statusText}`);
        }

        const data = await response.json();

        if (data.error) {
          throw new Error(`API error: ${data.error.message || 'Unknown error'}`);
        }

        const reply = data.choices?.[0]?.message?.content || "I couldn't understand that.";
        chatHistory.push({ role: "assistant", content: reply });
        return reply;
      } catch (error) {
        console.error('LLM API error:', error);
        const errorMessage = "Sorry, I'm having trouble processing your request. Please try again.";
        chatHistory.push({ role: "assistant", content: errorMessage });
        return errorMessage;
      }
    }

    async function createEvent(summary, dateTime, attendeeEmails = []) {
      try {
        const endDate = new Date(dateTime.getTime() + 60 * 60 * 1000);
        const event = {
          summary,
          start: { dateTime: dateTime.toISOString(), timeZone: 'UTC' },
          end: { dateTime: endDate.toISOString(), timeZone: 'UTC' }
        };
        
        // Add attendees if emails are provided
        if (attendeeEmails && attendeeEmails.length > 0) {
          event.attendees = attendeeEmails.map(email => ({ email: email.trim() }));
        }
        
        const res = await gapi.client.calendar.events.insert({
          calendarId: 'primary',
          resource: event
        });
        return res.result.htmlLink;
      } catch (error) {
        console.error('Calendar API error:', error);
        throw new Error('Failed to create calendar event. Please check your permissions and try again.');
      }
    }

    async function createEventFromDetails() {
      try {
        // Generate a smart event name using LLM
        const summary = await generateSmartEventName();

        // Parse date and time to create a proper DateTime
        const dateTime = parseDateTime(eventDetails.date, eventDetails.time);

        if (!dateTime) {
          throw new Error('Could not parse the date and time information');
        }

        // Debug logging
        console.log('Base date for session:', baseDate.toLocaleString());
        console.log('Event details:', eventDetails);
        console.log('Parsed dateTime:', dateTime);
        console.log('Current real time:', new Date());

        // Validate that the date is in the future relative to base date (with some tolerance)
        const timeDiff = dateTime.getTime() - baseDate.getTime();
        const hoursDiff = timeDiff / (1000 * 60 * 60);

        if (hoursDiff < -1) { // Allow 1 hour tolerance for past events
          throw new Error(`Event date must be in the future. The specified time (${dateTime.toLocaleString()}) is in the past relative to the session start time (${baseDate.toLocaleString()}).`);
        }

        const eventLink = await createEvent(summary, dateTime, eventDetails.attendeeEmails);
        const inviteInfo = eventDetails.attendeeEmails.length > 0 ? ` (Invites sent to: ${eventDetails.attendeeEmails.join(', ')})` : '';
        msg.innerHTML = `ðŸ“… Event created: <a href="${eventLink}" target="_blank">${summary}</a>${inviteInfo}`;

        // Reset for next event
        questionCount = 0;
        chatHistory = [];
        eventDetails = { date: null, time: null, attendees: null, location: null, attendeeEmails: [] };
        // Reset base date for new session
        baseDate = new Date();
        console.log('New session started with base date:', baseDate.toLocaleString());

      } catch (error) {
        console.error('Event creation error:', error);
        msg.textContent = `âš ï¸ ${error.message}`;
        questionCount = 0;
        chatHistory = [];
        eventDetails = { date: null, time: null, attendees: null, location: null, attendeeEmails: [] };
      }
    }

    inputBox.addEventListener('keydown', async (e) => {
      if (e.key !== 'Enter') return;
      const text = inputBox.value.trim();
      if (!text) return;

      msg.textContent = 'ðŸ¤– Thinking...';
      inputBox.value = '';
      inputBox.disabled = true;
      questionCount++;

      // Update event details with user input
      updateEventDetails(text);

      // Debug logging
      console.log('After updateEventDetails:', eventDetails);
      console.log('Has all info:', eventDetails.date && eventDetails.time && eventDetails.attendees && eventDetails.location);

      // Check if we have all required information
      const hasBasicInfo = eventDetails.date && eventDetails.time && eventDetails.attendees && eventDetails.location;
      const needsEmailInvitation = requiresEmailInvitation();
      const hasEmailsWhenNeeded = !needsEmailInvitation || eventDetails.attendeeEmails.length > 0;
      const hasAllInfo = hasBasicInfo && hasEmailsWhenNeeded;
      const isFinal = questionCount >= 6; // Fallback to prevent infinite loops

      console.log(`Event processing: hasBasicInfo=${hasBasicInfo}, needsEmailInvitation=${needsEmailInvitation}, hasEmailsWhenNeeded=${hasEmailsWhenNeeded}, hasAllInfo=${hasAllInfo}`);
      console.log(`Current eventDetails:`, eventDetails);

      // If we have all basic info but need emails, ask for them via AI
      if (hasBasicInfo && needsEmailInvitation && eventDetails.attendeeEmails.length === 0) {
        console.log('All basic info gathered, but need email for invitation - continuing to AI');
        // Continue to AI to ask for email
      }
      // If we have all info including emails (when needed), create event directly
      else if (hasAllInfo) {
        console.log('All information complete - creating event directly');
        msg.textContent = 'ðŸŽ¯ All information gathered! Creating your event...';
        await createEventFromDetails();
        return;
      }

      const reply = await sendToLLM(text, isFinal);

      if (isFinal) {
        try {
          const jsonMatch = reply.match(/{[^}]+}/);
          if (jsonMatch) {
            const parsed = JSON.parse(jsonMatch[0]);
            const { summary, dateTime } = parsed;

            // Validate date string
            const eventDate = new Date(dateTime);
            if (isNaN(eventDate.getTime())) {
              throw new Error('Invalid date format received from AI');
            }

            // Check if date is in the future relative to base date (with tolerance)
            const timeDiff = eventDate.getTime() - baseDate.getTime();
            const hoursDiff = timeDiff / (1000 * 60 * 60);

            if (hoursDiff < -1) { // Allow 1 hour tolerance for past events
              throw new Error(`Event date must be in the future. The specified time (${eventDate.toLocaleString()}) is in the past relative to the session start time (${baseDate.toLocaleString()}).`);
            }

            // Generate smart event name instead of using basic summary
            const smartEventName = await generateSmartEventName();

            const eventLink = await createEvent(smartEventName, eventDate, eventDetails.attendeeEmails);
            const inviteInfo = eventDetails.attendeeEmails.length > 0 ? ` (Invites sent to: ${eventDetails.attendeeEmails.join(', ')})` : '';
            msg.innerHTML = `ðŸ“… Event created: <a href="${eventLink}" target="_blank">${smartEventName}</a>${inviteInfo}`;
            questionCount = 0;
            chatHistory = [];
            eventDetails = { date: null, time: null, attendees: null, location: null, attendeeEmails: [] };
            // Reset base date for new session
            baseDate = new Date();
            console.log('New session started with base date:', baseDate.toLocaleString());
            return;
          } else {
            throw new Error('No valid JSON found in response');
          }
        } catch (err) {
          console.error('Event creation error:', err);
          msg.textContent = `âš ï¸ ${err.message || "I couldn't understand the schedule details. Please try again."}`;
          questionCount = 0;
          chatHistory = [];
          eventDetails = { date: null, time: null, attendees: null, location: null, attendeeEmails: [] };
          // Reset base date for new session
          baseDate = new Date();
        }
      } else {
        // Check again if we now have all info after AI response
        const hasBasicInfoAfterAI = eventDetails.date && eventDetails.time && eventDetails.attendees && eventDetails.location;
        const needsEmailAfterAI = requiresEmailInvitation();
        const hasEmailsWhenNeededAfterAI = !needsEmailAfterAI || eventDetails.attendeeEmails.length > 0;
        const hasAllInfoAfterAI = hasBasicInfoAfterAI && hasEmailsWhenNeededAfterAI;

        if (hasAllInfoAfterAI) {
          msg.textContent = 'ðŸŽ¯ All information gathered! Creating your event...';
          await createEventFromDetails();
          return;
        }

        // Show progress indicator and gathered info
        const progressInfo = `<br><br><small>ðŸ“‹ Progress: ${4 - getMissingInfo().length}/4 details gathered</small>`;

        const gatheredInfo = eventDetails.date || eventDetails.time || eventDetails.attendees || eventDetails.location
          ? `<br><small>âœ… Gathered: ${[eventDetails.date, eventDetails.time, eventDetails.attendees, eventDetails.location].filter(Boolean).join(', ')}</small>`
          : '';

        msg.innerHTML = `<strong>ðŸ¤– Assistant:</strong><br>${reply.replace(/\n/g, '<br>')}${progressInfo}${gatheredInfo}`;
      }

      // Re-enable input box after processing
      inputBox.disabled = false;
    });

    window.onload = () => {
      gapiLoaded();
      gisLoaded();
      // Set base date for the session
      baseDate = new Date();
      console.log('Session started with base date:', baseDate.toLocaleString());
      
      // Register PWA Service Worker
      if ('serviceWorker' in navigator) {
        navigator.serviceWorker.register('../sw.js')
          .then((registration) => {
            console.log('SW registered: ', registration);
          })
          .catch((registrationError) => {
            console.log('SW registration failed: ', registrationError);
          });
      }
    };
</script>
</body>
</html>
